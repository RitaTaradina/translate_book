# 10.6 The ros2opencv2.pyUtility

Многие из наших узлов видения ROS будут иметь общий набор функций, таких как преобразование из ROS в формат изображения OpenCV с использованием cv\_bridge, рисование текста на экране, что позволяет пользователю выбирать области мышью и так далее. Поэтому мы начнем с программирования сценария, который заботится об этих общих задачах и может быть включен в другие узлы.

Файл ros2opencv2.py, найденный в подкаталоге rbx1\_vision / src / rbx1\_vision, выполняет следующие задачи:

* Подписывается на тему необработанных изображений, опубликованную драйвером камеры. Формат этого изображения определяется типом сообщения ROS sensor\_msgs / Image. 
* Создает экземпляр утилиты ROS cv\_bridge, которая преобразует формат изображения ROS в формат OpenCV. 
* Создает окно отображения OpenCV для мониторинга изображения. 
* Создает обратный вызов для обработки щелчков мышью пользователем; например, выбор регион для отслеживания. 
* Создает функцию process\_image \(\), которая будет выполнять всю работу по обработке изображения и возвращению результатов. 
*  Создает функцию process\_depth\_image \(\) для обработки изображения глубины. 
* Публикует интересующую область \(ROI\) по теме / roi, которая содержит пиксели или ключевые точки, которые возвращаются process\_image \(\). 
* Сохраняет местоположение текущей обнаруженной цели в глобальной переменной self.detect\_box. 
* Сохраняет местоположение отслеживаемой в данный момент цели в глобальной переменной. self.track\_box.

Другие узлы ROS, которые мы разрабатываем ниже, будут переопределять функции process\_image \(\) и / или process\_depth\_image \(\) и обнаруживать определенные функции, такие как лица или цвета, а также отслеживать ключевые точки, найденные в обнаруженной области.

Большая часть кода в этом скрипте довольно проста и просто расширяется на сценарий cv\_bridge\_demo.py, который мы видели ранее, поэтому мы не будем проходить через него построчно. \(Сценарий тщательно прокомментирован и должен дать вам хорошее представление о том, что делает каждая часть. Вы также можете просмотреть его здесь:

Ссылка на источник: [ros2opencv2](https://github.com/pirobot/rbx1/blob/indigo-devel/rbx1_vision/src/rbx1_vision/ros2opencv2.py)

Но прежде чем перейти к более сложной обработке зрения, давайте протестируем узел ros2opencv2.py самостоятельно. После запуска драйвера вашей камеры перейдите к другому терминалу и запустите файл ros2opencv2.launch следующим образом:

```text
$ roslaunch rbx1_vision ros2opencv2.launch
```

После небольшой паузы вы должны увидеть окно отображения OpenCV. По умолчанию вы также увидите скорость обработки \(CPS = циклов в секунду\) и разрешение изображения. \(Количество циклов в секунду является обратной величиной времени, которое требуется для обработки одного кадра. Следовательно, это оценка самой быстрой частоты кадров, которую мы можем обработать.\) Вы можете изменить размер окна, перетащив один из углов. Если щелкнуть точку на изображении, на изображении в этом месте появится маленький желтый кружок или точка. Если вы перетащите изображение, прямоугольник выделения будет отображаться желтым цветом, пока вы не отпустите кнопку мыши, и в этот момент она станет зеленой и останется на изображении. Зеленая рамка представляет интересующую вас область \(ROI\). Чтобы увидеть координаты ROI, откройте другой терминал и просмотрите тему / roi:

* 
```text
$ rostopic echo /roi
```

Попробуйте нарисовать разные прямоугольники в окне изображения, и вы увидите, что значения полей ROI соответственно изменятся. Значение этих полей:

* x\_offset: x-координата верхнего левого угла уголка 
*  y\_offset: y-координата верхнего левого угла уголка 
* высота: высота, область, пиксели • ширина: ширина 
* do\_rectify: booleanvalue \(TrueorFalse\). Обычно ложь, что означает, что ROI определяется по отношению ко всему изображению. Однако, если правда, то рентабельность определяется в отдельном окне изображение . 

Обратите внимание, что координаты смещения относятся к верхнему левому углу окна изображения, которое имеет координаты \(0, 0\). Положительные значения x увеличиваются вправо, а значения y увеличиваются вниз. Наибольшее значение x равно width – 1, а наибольшее значение y - height – 1.

